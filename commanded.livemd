<!-- livebook:{"file_entries":[{"file":{"file_system_id":"local","file_system_type":"local","path":"/Users/mnecibi/Documents/MyProjects/Meetups/Commanded/foodbank/data/meetup_cologne.jpeg"},"name":"meetup_cologne.jpeg","type":"file"}]} -->

# Commanded: From theory to reality

```elixir
logo = Application.app_dir(:foodbank) <> "/priv/meetup_cologne.jpeg"

# File.read!("priv/meetup_cologne.jpeg")

```

## Welcome

![image](http://localhost:8080/foodbank/priv/meetup_cologne.jpeg)

<!-- livebook:{"break_markdown":true} -->

### Presentation + Code Examples

![image](http://localhost:8080/foodbank/data/github_qr_code.png)

https://github.com/mnecibi/foodbank

## About us

### Mehdi

```mermaid
timeline
    section Education - 5 years
      Computer science student : Discovered func-programming (Ocaml)
    section Java - 5 years
      Fullstack Developer: Java + JS Frontend frameworks + Adobe Products
    section Elixir - 2 years
      Fullstack Developer: Elixir + Phoenix/Liveview + Docker/Kubernetes
```

<!-- livebook:{"break_markdown":true} -->

#### Arne

```mermaid
timeline
    section Education - 1 year
      retraining programing in web development: Javascript, React, Html , Css 
   
    section Elixir - 1 year +
       Developer: Elixir + Phoenix/Liveview 
```

<!-- livebook:{"break_markdown":true} -->

### Inspired Consulting GmbH

```mermaid
pie title Projects Programming Languages
    "Elixir" : 40
    "Other (Java, Go ..etc)" : 60
```

## Core concepts

### Traditional System

```mermaid
block-beta
columns 1
  block:ID
    B["Command Operations
(insert/update/delete)"]
    C["Query Operations
(read/search/scan)"]
  end
  space
  D[("Database")]
  B --> D
  C --> D
```

<!-- livebook:{"break_markdown":true} -->

### CQRS (Command Query Responsibility Segregation)

```mermaid
block-beta
columns 1
  block:CO
    A["Command Operations
(insert/update/delete)"]
    CD[("Command DB")]
  end
  space
  block:QO
    B["Query Operations
(read/search/scan)"]
    QD[("Query DB")]
  end
  A --> CD 
  B --> QD
  QD --> CD
```

<!-- livebook:{"break_markdown":true} -->

### Event Sourcing

```mermaid
timeline
      Event 1 : BankAccountCreated : account_id 1 <br> initial_balance 0€
      Event 2 : MoneyDeposited : account_id 1 <br> amount 100€
      Event 3 : MoneyWithdraw : account_id 1 <br> amount 100€

```

<!-- livebook:{"break_markdown":true} -->

### Commanded

```mermaid
block-beta
  columns 5
  space
  block:ui_top:3
    columns 2

    UI1
    UI2
  end

  space
  UI

  block:logic_group:3
    columns 1

    block:QS
      columns 2
      QM1["Query Model 1"]
      QM2["Query Model 2"]
    end

    block:CS
      columns 2

      CM["Command Model"]
    end
  end

  block:db_group
    columns 1

    QDB[("Query DB")]
    space
    EDB[("EventStore")]
  end
UI1 --> QM1
UI2 --> QM2
QS --> QDB
CS --> EDB
UI --> CM
```

<!-- livebook:{"break_markdown":true} -->

CQRS + EventSourcing + Domain driver design

* Commands
* Events
* Aggregate
* Projections

## Some code - (Arne)

#### Commands

```elixir
defmodule Command.CreateTour do
  use TypedStruct

  typedstruct do
    field(:tour_id, binary())
    field(:name, String.t())
    field(:locations, [map()])
  end
end
```

#### Events

```elixir
defmodule Event.TourCreated do
  use TypedStruct
  use Foodbank.Event.EctoJsonSerializer.Decoder
  use Foodbank.Event.EctoJsonSerializer.Upcaster

  typedstruct do
    field(:tour_id, binary())
    field(:name, String.t())
    field(:locations, [map()])
  end
end
```



#### Aggregate

<!-- livebook:{"break_markdown":true} -->

Domain Driven Design

* State
* Gate Keeper

```elixir
defmodule Foodbank.Tour.Aggregate do
  use TypedStruct

  typedstruct do
    field(:tour_id, binary())
    field(:name, String.t())
    field(:locations, [map()])
  end

  #Crate Event
  def execute(_agg, %Command.CreateTour{tour_id: tour_id, name: name, locations: locations}) do
    %Event.TourCreated{tour_id: tour_id, name: name, locations: locations}
  end

  #Update Aggregate
  def apply(_agg, %Event.TourCreated{} = event) do
    %__MODULE__{tour_id: event.tour_id, name: event.name, locations: event.locations}
  end
end

```

## Router

```elixir
defmodule Foodbank.Router do
  use Commanded.Commands.Router, application: Foodbank.Commanded

  identify(Foodbank.Tour.Aggregate, by: :tour_id, prefix: "foodbank__tour_")

  dispatch([Command.CreateTour], to: Foodbank.Tour.Aggregate)
end
```

#### Let's create a tour

```elixir
%Command.CreateTour{
  tour_id: Ecto.UUID.generate(),
  name: "My Tour",
  locations: [
    %{
      address: "Aldi Cologne",
      type: "pickup"
    },
    %{
      address: "Lidl Cologne",
      type: "pickup"
    }
  ]
}
|> Foodbank.Router.dispatch()
```

```elixir
{:ok, events} = Foodbank.EventStore.read_all_streams_forward()
```

### Create Tables from Events (Mehdi)

```elixir
defmodule Foodbank.DBTour do
  use Ecto.Schema
  use TypedEctoSchema
  import Ecto.Changeset
  
  @primary_key {:tour_id, Ecto.UUID, autogenerate: false}
  typed_schema "tours" do
    field :name, :string
    field :locations, {:array, :map}
  end

  def changeset(tour \\ %__MODULE__{}, attrs) do
    tour
    |> cast(attrs, __schema__(:fields))
  end
end

defmodule Migrations.CreateTourTable do
  use Ecto.Migration

  def change do
    create table(:tours, primary_key: false) do
      add(:tour_id, :uuid, primary_key: true)
      add(:name, :name)
      add(:locations, :jsonb)
    end
  end
end

Ecto.Migrator.up(Foodbank.Repo, 1, Migrations.CreateTourTable)
```

### Populate the `tours` table using a Projector

```elixir
defmodule Foodbank.Tour.Projector do
  alias Foodbank.DBTour

  alias Event.TourCreated

  use Commanded.Projections.Ecto, name: "TourProjection", repo: Foodbank.Repo

  project(%TourCreated{} = event, _, fn multi ->
    Ecto.Multi.insert(multi, :tour, %DBTour{tour_id: event.tour_id, name: event.name, locations: event.locations})
  end)
end
```

```elixir
Foodbank.Tour.Projector.start_link(application: Foodbank.Commanded)
```

```elixir
Foodbank.DBTour |> Foodbank.Repo.all()
```

```elixir

```

#### Additional Ideas (Mehdi)

* EventHandler
  * notifications
  * mails
  * generate reports (csv/pdf documents)
* Projections (for statistics)
  * reseting
  * cleanup

<!-- livebook:{"break_markdown":true} -->

Compare Commanded with Other Tools

#### Commanded Pros

* Event Ordering
* Consistency
* Sepration of conserns (Data model do not leak from one use case to another)

#### Bonus Topics

* Auditing
* Debugging
* Historic State (Time Travel)
* Data security (GDPR)
* Authentication
* Trackability Tracability
* Statistics

<!-- livebook:{"break_markdown":true} -->

#### Our reference project Tafel

* Problems
  * 6 million events (so we cannot easily reset projection without down time)

<!-- livebook:{"offset":6793,"stamp":{"token":"XCP.oJHXEwp7t4Y-cpQ5Z6RybgebqPp4HtDNJzESaGJi-Hep0nHjcbWNKIFS3q9LBvVEh6T8n_MJDl6h9Ne40B25zH7MQ64mxrOLlzm49b6CwGGXUs-FR7rFZqzO3KVM3YcJhJoD7hxztGch","version":2}} -->
